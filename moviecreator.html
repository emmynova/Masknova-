<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MaskNova Studio — AI Movie Creator</title>
  <style>
    :root{
      --bg:#07070b; --panel:#0f1720; --muted:#9aa4b2; --accent1:#00e5ff; --accent2:#7a5cff;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#020214,#071026);color:#fff;min-height:100vh}
    /* Header */
    header{display:flex;align-items:center;gap:16px;padding:12px 20px;background:linear-gradient(90deg,#071026, #081227);border-bottom:1px solid rgba(255,255,255,0.03)}
    .logo{
      display:flex;align-items:center;gap:10px;font-weight:800;font-size:20px;
      background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;color:transparent;
    }
    .project-title{flex:1;text-align:center;font-size:18px}
    .top-actions button{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;padding:8px 12px;border-radius:8px;color:#000;font-weight:700;cursor:pointer;margin-left:8px}

    /* Layout */
    .app{display:grid;grid-template-columns:260px 1fr 280px;gap:12px;padding:16px}
    .left,.right{background:var(--panel);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04)}
    .center{background:transparent;display:flex;flex-direction:column;gap:12px}
    h3{margin:6px 0;color:var(--accent1)}
    label{display:block;font-size:13px;color:var(--muted);margin-top:8px}

    /* Media list */
    .media-list{display:flex;flex-direction:column;gap:8px;max-height:50vh;overflow:auto;padding-right:6px}
    .media-item{display:flex;align-items:center;gap:8px;background:var(--glass);padding:8px;border-radius:8px}
    .media-item small{color:var(--muted);font-size:12px}

    /* Preview */
    .preview-panel{background:#05060a;border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03); display:flex;flex-direction:column; align-items:center;}
    #previewCanvas{background:#000; width:100%; max-width:960px; height:540px; border-radius:8px; display:block}
    .preview-controls{display:flex;gap:8px;margin-top:8px;align-items:center}

    /* Timeline */
    .timeline{background:var(--panel);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .timeline-list{display:flex;gap:8px;overflow:auto;padding:6px}
    .clip-card{min-width:180px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:8px; border-radius:8px; cursor:grab; border:1px solid rgba(255,255,255,0.02)}
    .clip-card img{width:100%; height:80px; object-fit:cover; border-radius:6px}
    .clip-actions{display:flex;gap:6px;margin-top:6px}

    /* right panel */
    .select, select, button {width:100%}
    .small{font-size:13px;color:var(--muted)}

    footer{padding:18px;text-align:center;color:var(--muted)}
    .pill{display:inline-block;padding:6px 10px;background:rgba(255,255,255,0.03);border-radius:999px;font-weight:600}
    /* responsive */
    @media (max-width:1000px){
      .app{grid-template-columns:1fr; padding:12px}
      .left,.right{order:2}
      .center{order:1}
      #previewCanvas{height:360px}
    }
  </style>
</head>
<body>

<header>
  <div class="logo">MaskNova <span style="font-weight:700;color:var(--accent2);margin-left:2px">Studio</span></div>
  <div class="project-title">Project: <input id="projectName" style="background:transparent;border:none;color:#fff;font-weight:700" value="My Movie Project" /></div>
  <div class="top-actions">
    <button id="saveProjBtn">Save</button>
    <button id="exportBtn">Export Movie</button>
  </div>
</header>

<div class="app">
  <!-- LEFT: Media Library -->
  <aside class="left">
    <h3>Media Library</h3>

    <label>Upload Files (Images / Video)</label>
    <input type="file" id="fileInput" multiple accept="video/*,image/*" />

    <label>Upload Audio (Music / Voice)</label>
    <input type="file" id="audioInput" accept="audio/*" />

    <div style="height:10px"></div>
    <button id="addImagesToTimeline">Create Slideshow from Selected Images</button>

    <h3 style="margin-top:12px">Clips</h3>
    <div class="media-list" id="mediaList"></div>

    <p class="small" style="margin-top:10px">Tip: drag clips from the library to the timeline below. Use the right panel to trim and apply filters.</p>
  </aside>

  <!-- CENTER: Preview + Timeline -->
  <main class="center">
    <div class="preview-panel">
      <canvas id="previewCanvas" width="960" height="540"></canvas>
      <div class="preview-controls">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <label class="small" style="margin-left:6px">Speed</label>
        <select id="playbackRate">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
        </select>
        <label class="small" style="margin-left:10px">Filter</label>
        <select id="globalFilter">
          <option value="none">None</option>
          <option value="cinematic">Cinematic</option>
          <option value="bw">Black & White</option>
          <option value="vintage">Vintage</option>
          <option value="cyberpunk">Cyberpunk</option>
        </select>
      </div>
    </div>

    <div class="timeline" style="margin-top:12px">
      <h3>Timeline</h3>
      <div class="timeline-list" id="timelineList"></div>
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button id="addBlankClip">Add Blank Clip</button>
        <button id="clearTimeline">Clear Timeline</button>
      </div>
    </div>
  </main>

  <!-- RIGHT: Properties -->
  <aside class="right">
    <h3>Properties</h3>
    <div id="propertiesBox">
      <p class="small">Select a clip in the timeline to edit its settings.</p>
    </div>

    <h3 style="margin-top:12px">Export</h3>
    <label>Resolution</label>
    <select id="exportRes">
      <option value="640">640×360</option>
      <option value="960" selected>960×540</option>
      <option value="1280">1280×720</option>
    </select>

    <label style="margin-top:8px">FPS</label>
    <select id="exportFps">
      <option value="24">24</option>
      <option value="30" selected>30</option>
      <option value="60">60</option>
    </select>

    <div style="height:12px"></div>
    <p class="small">Advanced AI features (scene generator, motion fx, pro filters) — <span class="pill">coming soon</span></p>
  </aside>
</div>

<footer>
  MaskNova Studio — lightweight web studio. Export uses browser recording. For large pro exports, server-side rendering will be required.
</footer>

<script>
/*
  MaskNova Studio - lightweight web editor core
  - mediaLibrary: stores uploaded files (images/videos/audio)
  - timeline: ordered sequence of clips {id,type,src,start,duration,filter}
  - preview: draws current clip to canvas and plays sequentially
  - export: records canvas with MediaRecorder
*/

// state
const mediaLibrary = []; // {id, type: 'image'|'video'|'audio', file, url, name}
const timeline = [];     // {id, mediaId, type, startTrim, endTrim, duration, filter}
let selectedClipIndex = -1;
let playing = false;
let playbackRate = 1;
let globalFilter = 'none';
let recorder; let recordedChunks = [];

// utils
const uid = (n=6)=>Math.random().toString(36).slice(2,2+n);

// DOM
const fileInput = document.getElementById('fileInput');
const audioInput = document.getElementById('audioInput');
const mediaList = document.getElementById('mediaList');
const timelineList = document.getElementById('timelineList');
const previewCanvas = document.getElementById('previewCanvas');
const ctx = previewCanvas.getContext('2d');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const addImagesToTimelineBtn = document.getElementById('addImagesToTimeline');
const addBlankClipBtn = document.getElementById('addBlankClip');
const clearTimelineBtn = document.getElementById('clearTimeline');
const propertiesBox = document.getElementById('propertiesBox');
const exportBtn = document.getElementById('exportBtn');
const playbackRateSelect = document.getElementById('playbackRate');
const globalFilterSelect = document.getElementById('globalFilter');
const exportRes = document.getElementById('exportRes');
const exportFps = document.getElementById('exportFps');

// handle uploads
fileInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files || []);
  for(const f of files){
    const url = URL.createObjectURL(f);
    const type = f.type.startsWith('video/') ? 'video' : 'image';
    const item = { id: uid(), type, file: f, url, name: f.name };
    mediaLibrary.push(item);
    addMediaToUI(item);
  }
  fileInput.value='';
});

audioInput.addEventListener('change', (e)=>{
  const files = Array.from(e.target.files || []);
  for(const f of files){
    const url = URL.createObjectURL(f);
    const item = { id: uid(), type: 'audio', file: f, url, name: f.name };
    mediaLibrary.push(item);
    addMediaToUI(item);
  }
  audioInput.value='';
});

// add to media list UI
function addMediaToUI(item){
  const el = document.createElement('div');
  el.className='media-item';
  const thumb = document.createElement('div');
  thumb.style.width='56px'; thumb.style.height='40px'; thumb.style.flex='0 0 56px'; thumb.style.overflow='hidden'; thumb.style.borderRadius='6px';
  if(item.type === 'image'){
    const img = document.createElement('img'); img.src=item.url; img.style.width='56px'; img.style.height='40px'; img.style.objectFit='cover';
    thumb.appendChild(img);
  } else if(item.type === 'video'){
    const vid = document.createElement('video'); vid.src=item.url; vid.muted=true; vid.style.width='56px'; vid.style.height='40px'; vid.style.objectFit='cover';
    thumb.appendChild(vid);
  } else {
    const ico = document.createElement('div'); ico.textContent='🎵'; ico.style.fontSize='22px'; ico.style.display='flex'; ico.style.alignItems='center'; ico.style.justifyContent='center';
    thumb.appendChild(ico);
  }
  el.appendChild(thumb);
  const info = document.createElement('div'); info.style.flex='1';
  info.innerHTML=`<div style="font-weight:700">${item.name}</div><small>${item.type}</small>`;
  el.appendChild(info);

  const actions = document.createElement('div'); actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='6px';
  const addBtn = document.createElement('button'); addBtn.textContent='Add →'; addBtn.onclick=()=>{ addToTimeline(item.id) };
  actions.appendChild(addBtn);
  el.appendChild(actions);

  mediaList.prepend(el);
}

// timeline functions
function addToTimeline(mediaId){
  const media = mediaLibrary.find(m=>m.id===mediaId);
  if(!media) return;
  let duration = 4;
  if(media.type==='video'){
    // attempt to read actual duration by loading video element
    const v = document.createElement('video'); v.src = media.url;
    v.addEventListener('loadedmetadata', ()=>{
      const dur = Math.min(Math.max(1, Math.floor(v.duration)), 60);
      pushClip(mediaId, 0, Math.floor(dur), dur);
    });
    return;
  }
  pushClip(mediaId, 0, duration, duration);
}
function pushClip(mediaId, start=0, end=4, duration=4){
  const clip = { id: uid(), mediaId, type: mediaLibrary.find(m=>m.id===mediaId).type, startTrim:start, endTrim:end, duration, filter:'none' };
  timeline.push(clip);
  renderTimeline();
}
function renderTimeline(){
  timelineList.innerHTML='';
  timeline.forEach((clip, i)=>{
    const media = mediaLibrary.find(m=>m.id===clip.mediaId);
    const card = document.createElement('div'); card.className='clip-card';
    card.draggable=true;
    card.onclick=()=> selectClip(i);
    card.ondragstart = (ev)=>{ ev.dataTransfer.setData('text/plain', i) };
    card.ondragover = (ev)=>ev.preventDefault();
    card.ondrop = (ev)=>{ ev.preventDefault(); const from = parseInt(ev.dataTransfer.getData('text/plain')); moveClip(from,i) };

    const thumb = document.createElement('div');
    if(media.type==='image'){ thumb.innerHTML = `<img src="${media.url}">`; }
    else if(media.type==='video'){ thumb.innerHTML = `<video src="${media.url}" muted style="width:100%;height:80px;object-fit:cover"></video>`; }
    else { thumb.textContent='Audio'; }

    const tit = document.createElement('div'); tit.style.marginTop='6px'; tit.innerHTML = `<strong>${media.name}</strong><div class="small">${clip.type} • ${clip.duration}s</div>`;
    const actions = document.createElement('div'); actions.className='clip-actions';
    const del = document.createElement('button'); del.textContent='Delete'; del.onclick=(e)=>{ e.stopPropagation(); removeClip(i) };
    actions.appendChild(del);
    card.appendChild(thumb); card.appendChild(tit); card.appendChild(actions);
    timelineList.appendChild(card);
  });
}
function selectClip(index){
  selectedClipIndex = index;
  showProperties();
}
function removeClip(index){ timeline.splice(index,1); renderTimeline(); propertiesBox.innerHTML='<p class="small">Select a clip in the timeline to edit its settings.</p>'; }
function moveClip(from,to){
  const [item] = timeline.splice(from,1);
  timeline.splice(to,0,item);
  renderTimeline();
}

// properties panel
function showProperties(){
  propertiesBox.innerHTML='';
  if(selectedClipIndex<0 || !timeline[selectedClipIndex]){ propertiesBox.innerHTML='<p class="small">Select a clip in the timeline to edit its settings.</p>'; return; }
  const clip = timeline[selectedClipIndex];
  const media = mediaLibrary.find(m=>m.id===clip.mediaId);
  const box = document.createElement('div');
  box.innerHTML = `<div style="font-weight:700">${media.name}</div><div class="small">${clip.type}</div>`;
  // trim
  box.appendChild(document.createElement('hr'));
  const trimStartLabel = document.createElement('label'); trimStartLabel.textContent='Trim start (s)'; box.appendChild(trimStartLabel);
  const trimStart = document.createElement('input'); trimStart.type='number'; trimStart.value=clip.startTrim; trimStart.min=0; trimStart.onchange=()=>{ clip.startTrim = Number(trimStart.value); };
  box.appendChild(trimStart);
  const trimEndLabel = document.createElement('label'); trimEndLabel.textContent='Duration (s)'; box.appendChild(trimEndLabel);
  const trimEnd = document.createElement('input'); trimEnd.type='number'; trimEnd.value=clip.duration; trimEnd.min=0.5; trimEnd.onchange=()=>{ clip.duration = Number(trimEnd.value); renderTimeline(); };
  box.appendChild(trimEnd);

  // filter
  const filtLabel = document.createElement('label'); filtLabel.textContent='Filter'; box.appendChild(filtLabel);
  const filtSel = document.createElement('select'); ['none','cinematic','bw','vintage','cyberpunk'].forEach(v=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; if(clip.filter===v)o.selected=true; filtSel.appendChild(o) });
  filtSel.onchange=()=>{ clip.filter = filtSel.value; };
  box.appendChild(filtSel);

  // preview clip
  const playNow = document.createElement('button'); playNow.textContent='Play Clip'; playNow.onclick=()=> playSingleClip(clip);
  box.appendChild(playNow);

  propertiesBox.appendChild(box);
}

// preview playback engine
let playCursor = 0;
let timelinePlaying = false;
let stopRequested = false;

async function playTimeline(){
  if(timeline.length===0) return alert('Timeline is empty');
  playing=true; timelinePlaying=true; stopRequested=false; playCursor=0;
  for(let i=0;i<timeline.length;i++){
    if(stopRequested) break;
    const clip = timeline[i];
    await playClipLive(clip);
  }
  timelinePlaying=false; playing=false;
}

function pauseTimeline(){
  stopRequested = true;
  playing=false;
}

// play single clip (from properties)
function playSingleClip(clip){
  (async ()=>{ await playClipLive(clip); })();
}

// helpers: playClipLive draws into canvas for the clip duration
function applyCanvasFilter(ctx, filter, w, h){
  // simple color transforms implemented via globalComposite or tinting; for now use overlay styles
  // We'll use simple CSS-like filters via drawing to temp canvas then manipulating pixels for bw/vintage - but keep it simple for performance
  // For performance, we implement via ctx.filter where supported.
  switch(filter){
    case 'cinematic':
      ctx.filter='contrast(1.15) saturate(1.05)'; break;
    case 'bw': ctx.filter='grayscale(1)'; break;
    case 'vintage': ctx.filter='sepia(0.4) saturate(0.9)'; break;
    case 'cyberpunk': ctx.filter='hue-rotate(200deg) saturate(1.5) contrast(1.1)'; break;
    default: ctx.filter='none';
  }
}

function drawImageCover(ctx, img, x,y,w,h, alpha=1){
  ctx.save(); ctx.globalAlpha=alpha;
  ctx.drawImage(img, x, y, w, h);
  ctx.restore();
}

// this function handles both images and videos
function playClipLive(clip){
  return new Promise(async (resolve)=>{
    const media = mediaLibrary.find(m=>m.id===clip.mediaId);
    const w = previewCanvas.width, h = previewCanvas.height;
    const filterToUse = clip.filter || globalFilter;
    // decide what to do based on type
    if(clip.type === 'image'){
      const img = new Image(); img.src = media.url;
      await img.decode().catch(()=>{});
      const dur = clip.duration * (1/Number(playbackRateSelect.value));
      const fps = 30;
      const frames = Math.max(1,Math.floor(dur*fps));
      let t0 = performance.now();
      for(let f=0; f<frames; f++){
        if(stopRequested) break;
        ctx.clearRect(0,0,w,h);
        applyCanvasFilter(ctx, filterToUse, w, h);
        // simple crossfade effect: during first/last 10% fade
        const progress = f/frames;
        let alpha = 1;
        const fade = 0.12;
        if(progress < fade) alpha = progress/fade;
        if(progress > 1-fade) alpha = (1-progress)/fade;
        drawImageCover(ctx, img, 0,0,w,h, alpha);
        await new Promise(r=>setTimeout(r, 1000/fps));
      }
      ctx.filter='none';
      resolve();
    } else if(clip.type === 'video'){
      const v = document.createElement('video');
      v.src = media.url;
      v.muted = true;
      v.crossOrigin = 'anonymous';
      v.playsInline = true;
      // wait loadedmetadata
      v.addEventListener('loadedmetadata', async ()=>{
        const start = Math.min(Math.max(0, clip.startTrim || 0), v.duration-0.01);
        const dur = Math.min(clip.duration || (v.duration - start), v.duration - start);
        v.currentTime = start;
        const fps = 30;
        const endTime = start + dur;
        let playingVideo = true;
        v.playbackRate = parseFloat(playbackRateSelect.value);
        try{ await v.play(); }catch(e){}
        function step(){
          if(stopRequested || v.currentTime >= endTime){
            try{ v.pause(); }catch(e){}
            resolve();
            return;
          }
          ctx.clearRect(0,0,w,h);
          applyCanvasFilter(ctx, filterToUse, w, h);
          try{ ctx.drawImage(v, 0,0,w,h); }catch(e){}
          requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
      });
      v.addEventListener('error', ()=>{ console.error('video load error'); resolve(); });
    } else {
      // audio only: just render a black screen while audio plays (not implemented in this demo)
      const dur = clip.duration;
      const start = performance.now();
      while(performance.now() - start < dur*1000){
        if(stopRequested) break;
        await new Promise(r=>setTimeout(r,200));
      }
      resolve();
    }
  });
}

// preview play/pause
playBtn.onclick = ()=>{ if(!timelinePlaying) playTimeline(); else { /* already playing */ } };
pauseBtn.onclick = ()=>{ pauseTimeline(); };

// export: record canvas stream
exportBtn.addEventListener('click', async ()=>{
  if(timeline.length===0) return alert('Add clips to timeline first');
  const exportWidth = Number(exportRes.value);
  const exportHeight = Math.round(exportWidth * (previewCanvas.height/previewCanvas.width));
  const fps = Number(exportFps.value);
  // temporarily set canvas to export size
  const savedWidth = previewCanvas.width, savedHeight = previewCanvas.height;
  previewCanvas.width = exportWidth;
  previewCanvas.height = exportHeight;

  // start recording
  recordedChunks = [];
  const stream = previewCanvas.captureStream(fps);
  recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
  recorder.ondataavailable = (e)=>{ if(e.data.size) recordedChunks.push(e.data); };
  recorder.onstop = ()=>{ const blob = new Blob(recordedChunks, {type:'video/webm'}); const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${document.getElementById('projectName').value || 'masknova_movie'}.webm`; a.click();
    // restore canvas size
    previewCanvas.width = savedWidth; previewCanvas.height = savedHeight;
  };
  recorder.start();

  // play timeline synchronously but ensure frames drawn to export canvas size
  stopRequested = false;
  for(let i=0;i<timeline.length;i++){
    if(stopRequested) break;
    await playClipLive(timeline[i]);
  }
  recorder.stop();
  stopRequested = false;
  alert('Export finished (download should begin). For higher-quality production, consider server-side rendering.');
});

// playback rate and global filter controls
playbackRateSelect.onchange = ()=> playbackRate = Number(playbackRateSelect.value);
globalFilterSelect.onchange = ()=> globalFilter = globalFilterSelect.value;

// helper: play single clip without altering UI
async function playClipLive(clip){
  // wrap the real function (avoid name clash)
  return await window.playClipLive_core ? window.playClipLive_core(clip) : (async ()=>{})();
}

// to avoid circular definitions, set the core function to our implementation
window.playClipLive_core = async function(clip){
  // same implementation as earlier function; reuse to avoid duplication
  // We'll call the inner implementation defined earlier (since it's already declared)
  // But because of function hoisting we can just call the original one named playClipLiveImplementation if existed.
  // For clarity, call the previously defined playClipLive (it exists).
  return await (async function(originalClip){
    // reuse the original playClipLive that was defined above above — but due to our previous function name we already have it.
    // In this file scope, playClipLive is the earlier implementation; so call it.
    return await (new Promise((res)=>{ // call the earlier defined function by invoking the function body above; to keep consistent, call the function named playClipLiveImplementation if present
      // fallback: call the existing implementation via the global reference created earlier:
      // This wrapper simply calls the earlier defined function using the closure.
      // For safety, call the originally created playClipLiveImplementation (we used playClipLive earlier).
      // We'll call the function defined earlier by name _playClipInternal (but since it's not separated, just call the function defined as playClipLiveOriginal).
      // To keep the code consistent, fallback to the same logic by reusing the declared implementation name "playClipLiveImplementation".
      res();
    })));
  })(clip);
};

// Because of the scope complications, simply reassign the real implementation:
window.playClipLive_core = (async function(clip){
  // invoke the playClipLive implementation defined above by referencing it directly (it exists in scope)
  // Here we call the function "playClipLive_raw" which is the original function implementation; actually it's "playClipLive" declared earlier.
  // So just call that:
  return await (typeof playClipLive === 'function' ? playClipLive(clip) : Promise.resolve());
});

// single-clip play (used in properties)
async function playSingleClip(clip){ await playClipLive(clip); }

// create slideshow from selected images: for demo, take all image-type media
addImagesToTimelineBtn.addEventListener('click', ()=>{
  const images = mediaLibrary.filter(m=>m.type==='image');
  if(images.length===0) return alert('No images uploaded');
  images.forEach(img=> pushClip(img.id,0,4,4));
  renderTimeline();
});

// blank clip
addBlankClipBtn.addEventListener('click', ()=>{
  const blank = { id: uid(), mediaId:null, type:'image', startTrim:0, endTrim:4, duration:4, filter:'none' };
  // create a temporary white frame by making a data URL
  const c = document.createElement('canvas'); c.width=960; c.height=540; const cc = c.getContext('2d'); cc.fillStyle='#000'; cc.fillRect(0,0,c.width,c.height);
  const url = c.toDataURL('image/png');
  const item = { id: uid(), type:'image', file:null, url, name:'Blank' };
  mediaLibrary.push(item); addMediaToUI(item);
  pushClip(item.id,0,4,4);
});

// clear timeline
clearTimelineBtn.addEventListener('click', ()=>{ timeline.length=0; renderTimeline(); propertiesBox.innerHTML='<p class="small">Select a clip in the timeline to edit its settings.</p>'; });

// initial state
renderTimeline();

</script>
</body>
</html>
