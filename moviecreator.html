<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SceneCraft — Pro Merge Demo (ffmpeg.wasm)</title>
<meta name="description" content="SceneCraft pro merge demo — merge multiple videos client-side with ffmpeg.wasm">
<style>
  :root{
    --bg:#060617; --panel:#0f1720; --muted:#9aa4b2; --accent1:#00e5ff; --accent2:#7a5cff;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#020214,#071026);color:#fff;min-height:100vh;display:flex;flex-direction:column}
  header{display:flex;align-items:center;gap:12px;padding:14px;border-bottom:1px solid rgba(255,255,255,0.03);background:linear-gradient(90deg,#040519,#071026)}
  .logo{font-weight:800;background:linear-gradient(90deg,var(--accent1),var(--accent2));-webkit-background-clip:text;color:transparent}
  main{padding:16px;flex:1;display:flex;flex-direction:column;gap:12px;max-width:980px;margin:0 auto;width:100%}
  .card{background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  input[type=file]{color:transparent}
  .file-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .file-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .btn{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#000;border:none;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  #log{height:160px;overflow:auto;background:#06060a;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:monospace;font-size:12px}
  .center{display:flex;justify-content:center;gap:8px;flex-wrap:wrap}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .thumb{width:120px;height:70px;object-fit:cover;border-radius:6px;background:#000}
  @media (max-width:720px){ .thumb{width:100px;height:60px} .row{flex-direction:column;align-items:stretch} }
</style>
</head>
<body>
  <header>
    <div class="logo">SceneCraft — Merge Engine</div>
  </header>

  <main>
    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong>Pro Video Merge (ffmpeg.wasm)</strong>
          <div class="small">Upload videos, reorder, then Merge → downloads final output.</div>
        </div>
        <div>
          <button id="loadFF" class="btn">Load FFmpeg</button>
        </div>
      </div>

      <hr style="opacity:0.06;margin:12px 0">

      <div class="row">
        <label class="small">Select video files (mp4/webm) — multiple allowed:</label>
        <input id="videoInput" type="file" accept="video/*" multiple />
      </div>

      <div class="file-list card" id="fileList" style="margin-top:10px"></div>

      <div style="margin-top:12px" class="controls">
        <button id="mergeBtn" class="btn" disabled>Merge Selected Videos</button>
        <button id="clearBtn" class="btn ghost">Clear</button>
        <label class="small" style="margin-left:8px">Output format:</label>
        <select id="outFormat" class="small" style="padding:6px;border-radius:6px;background:#0b0b10;color:#fff;border:1px solid rgba(255,255,255,0.04)">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM (fallback)</option>
        </select>
      </div>

      <div style="margin-top:12px">
        <div class="small">Console log / progress</div>
        <pre id="log"></pre>
      </div>
    </section>

    <section class="card">
      <strong>Tips</strong>
      <ul class="small" style="margin-top:8px">
        <li>ffmpeg.wasm loads a large WebAssembly bundle — click "Load FFmpeg" once before merging.</li>
        <li>For reliable merges we re-encode; merging may be CPU-heavy on phones.</li>
        <li>If MP4 export fails, switch to WebM output and try again.</li>
      </ul>
    </section>
  </main>

<script type="module">
import { createFFmpeg, fetchFile } from 'https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js';

const logEl = document.getElementById('log');
const fileInput = document.getElementById('videoInput');
const fileListEl = document.getElementById('fileList');
const mergeBtn = document.getElementById('mergeBtn');
const clearBtn = document.getElementById('clearBtn');
const outFormat = document.getElementById('outFormat');
const loadFF = document.getElementById('loadFF');

const ffmpeg = createFFmpeg({ log: true });
let ffmpegLoaded = false;

function log(msg){
  logEl.textContent += msg + '\n';
  logEl.scrollTop = logEl.scrollHeight;
  console.log(msg);
}

// load ffmpeg when user clicks
loadFF.addEventListener('click', async ()=>{
  if(ffmpegLoaded) { log('FFmpeg already loaded'); return; }
  log('Loading FFmpeg (this may take 5-20s depending on connection)...');
  try{
    await ffmpeg.load();
    ffmpegLoaded = true;
    log('FFmpeg loaded ✅');
    loadFF.textContent = 'FFmpeg Loaded';
    loadFF.classList.add('btn','ghost');
  } catch (e){
    log('Error loading FFmpeg: ' + e.message);
  }
});

// store selected files in array
let files = []; // {file, name, url}

fileInput.addEventListener('change', async (e)=>{
  const chosen = Array.from(e.target.files || []);
  for(const f of chosen){
    const url = URL.createObjectURL(f);
    files.push({ file: f, name: f.name, url });
  }
  renderFileList();
  e.target.value = '';
});

function renderFileList(){
  fileListEl.innerHTML = '';
  if(files.length === 0){
    fileListEl.innerHTML = '<div class="small">No files added yet</div>';
    mergeBtn.disabled = true;
    return;
  }
  files.forEach((it, idx) => {
    const div = document.createElement('div');
    div.className = 'file-item';
    const thumb = document.createElement('video');
    thumb.src = it.url; thumb.muted=true; thumb.playsInline=true; thumb.className='thumb';
    thumb.addEventListener('loadeddata', ()=>{ thumb.currentTime = 0.2; });
    const info = document.createElement('div');
    info.style.flex='1';
    info.innerHTML = `<div style="font-weight:700">${it.name}</div><div class="small">#${idx+1}</div>`;
    const actions = document.createElement('div');
    actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='6px';
    const up = document.createElement('button'); up.className='btn ghost'; up.textContent='↑'; up.onclick = ()=>{ if(idx>0){ [files[idx-1],files[idx]] = [files[idx],files[idx-1]]; renderFileList(); } };
    const down = document.createElement('button'); down.className='btn ghost'; down.textContent='↓'; down.onclick = ()=>{ if(idx < files.length-1){ [files[idx+1],files[idx]] = [files[idx],files[idx+1]]; renderFileList(); } };
    const del = document.createElement('button'); del.className='btn ghost'; del.textContent='Delete'; del.onclick = ()=>{ files.splice(idx,1); renderFileList(); };
    actions.appendChild(up); actions.appendChild(down); actions.appendChild(del);
    div.appendChild(thumb); div.appendChild(info); div.appendChild(actions);
    fileListEl.appendChild(div);
  });
  mergeBtn.disabled = false;
}

// clear files
clearBtn.addEventListener('click', ()=>{
  files.forEach(f=> URL.revokeObjectURL(f.url));
  files = [];
  renderFileList();
});

// merge logic
mergeBtn.addEventListener('click', async ()=>{
  if(files.length < 1) return alert('Add at least one video');
  if(!ffmpegLoaded){
    if(confirm('FFmpeg not loaded yet. Load now?')) { await loadFF.click(); }
    else return;
  }

  mergeBtn.disabled = true;
  log('Preparing files for merge...');

  try{
    // write input files to FS
    for(let i=0;i<files.length;i++){
      const name = `input${i}.mp4`; // write as mp4 extension for ffmpeg; actual content is fetched
      const data = await fetchFile(files[i].file);
      log(`Writing ${name} (${files[i].name})`);
      ffmpeg.FS('writeFile', name, data);
    }

    // Build ffmpeg command: re-encode and concat via filter_complex
    // Example for 2 inputs: -i input0.mp4 -i input1.mp4 -filter_complex "[0:v]scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2,setsar=1[v0];[1:v]...;[v0][0:a][v1][1:a]concat=n=2:v=1:a=1[outv][outa]" -map "[outv]" -map "[outa]" -c:v libx264 -preset veryfast out.mp4
    const n = files.length;
    // compute target resolution: use first video's width/height (we'll probe)
    // For simplicity use 1280x720 as safe default for re-encode
    const targetW = 1280;
    const targetH = 720;

    // create filter parts for video scaling and audio mapping
    const inputs = [];
    for(let i=0;i<n;i++) inputs.push('-i', `input${i}.mp4`);

    // build per-input video label transforms
    const vfParts = [];
    for(let i=0;i<n;i++){
      vfParts.push(`[${i}:v]scale=${targetW}:${targetH}:force_original_aspect_ratio=decrease,pad=${targetW}:${targetH}:(ow-iw)/2:(oh-ih)/2,setsar=1[v${i}]`);
    }
    // then concat
    // ensure audio track exists for each input; we'll map audio streams [i:a] if exist, else generate silent
    // To keep command simpler, we'll attempt to use audio streams directly and rely on ffmpeg to handle missing audio (but if missing, concat will fail).
    // Safer approach: add anullsrc for missing audio — but detection adds complexity. We'll try first and advise fallback.
    let concatInputs = '';
    for(let i=0;i<n;i++){
      concatInputs += `[v${i}][${i}:a]`;
    }
    const filterComplex = `${vfParts.join(';')};${concatInputs}concat=n=${n}:v=1:a=1[outv][outa]`;

    // output filename
    const outExt = (outFormat.value === 'mp4') ? 'mp4' : 'webm';
    const outName = `scene_output.${outExt}`;

    // ffmpeg arguments
    // If mp4 selected, try to encode with libx264; if that fails we'll try webm
    let args = [];
    args = args.concat(inputs);
    args = args.concat(['-filter_complex', filterComplex, '-map', '[outv]', '-map', '[outa]']);
    if(outExt === 'mp4'){
      args = args.concat(['-c:v', 'libx264', '-crf', '23', '-preset', 'veryfast', '-c:a', 'aac', '-b:a', '128k', outName]);
    } else {
      args = args.concat(['-c:v', 'libvpx-vp9', '-crf', '33', '-b:v', '0', '-c:a', 'libopus', outName]);
    }

    log('Running ffmpeg with args: ' + args.join(' '));
    // run ffmpeg
    await ffmpeg.run(...args);

    // read result
    log('Merging finished, reading output file...');
    const data = ffmpeg.FS('readFile', outName);
    const blob = new Blob([data.buffer], { type: outExt === 'mp4' ? 'video/mp4' : 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `scenecraft_merged.${outExt}`; document.body.appendChild(a); a.click(); a.remove();
    log('Download started — saved as scenecraft_merged.' + outExt);

    // cleanup FS entries to reduce memory
    for(let i=0;i<n;i++) ffmpeg.FS('unlink', `input${i}.mp4`);
    ffmpeg.FS('unlink', outName);

  } catch (err){
    log('Error during merge: ' + (err.message || err));
    // fallback: try WebM if mp4 failed
    if(outFormat.value === 'mp4'){
      log('MP4 merge failed — try switching Output format to WebM and run again.');
    }
  } finally {
    mergeBtn.disabled = false;
  }
});
</script>
</body>
</html>
