<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SceneCraft Studio — Editor (Powered by MaskNova)</title>
<style>
  :root{
    --bg:#070712; --card:#0f1720; --muted:#9aa4b2; --accent1:#00e5ff; --accent2:#7a5cff;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#030313,#070619);color:#fff;min-height:100vh}
  header{display:flex;align-items:center;gap:12px;padding:12px 14px;background:linear-gradient(90deg,#040519,#071026);border-bottom:1px solid rgba(255,255,255,0.03)}
  .logo{display:flex;align-items:center;gap:10px}
  .logo img{width:36px;height:36px;border-radius:8px;filter:drop-shadow(0 6px 16px rgba(122,92,255,0.14))}
  .title {font-weight:800;font-size:16px}
  .top-actions{margin-left:auto;display:flex;gap:8px;align-items:center}
  .btn {background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#000;border:none;padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:600}

  .wrap{display:flex;flex-direction:column;gap:12px;padding:12px}

  /* preview area */
  .preview-card{background:var(--card);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;align-items:center}
  #previewCanvas{width:100%;max-width:960px;border-radius:8px;background:#000;aspect-ratio:16/9}
  .preview-controls{display:flex;gap:8px;width:100%;align-items:center;margin-top:10px;flex-wrap:wrap}
  .small{font-size:13px;color:var(--muted)}

  /* tools bar (horizontal scroll) */
  .tools {display:flex;gap:8px;overflow:auto;padding:8px 2px 8px 2px}
  .tool {min-width:84px;background:var(--glass);padding:8px;border-radius:10px;text-align:center;color:#fff;font-weight:700;border:1px solid rgba(255,255,255,0.02);cursor:pointer}
  .tool.small {font-weight:600;font-size:13px}

  /* media & timeline */
  .row{display:flex;gap:12px;align-items:flex-start}
  .left-panel{flex:0 0 160px;background:var(--card);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .media-list{display:flex;flex-direction:column;gap:8px;max-height:48vh;overflow:auto;padding-right:6px}
  .media-item{display:flex;gap:8px;align-items:center;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent)}
  .media-item img{width:56px;height:40px;object-fit:cover;border-radius:6px}
  .media-item small{color:var(--muted);display:block}

  .timeline-panel{flex:1;background:var(--card);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .timeline-list{display:flex;gap:8px;overflow:auto;padding:8px}
  .clip{min-width:140px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
  .clip img{width:100%;height:72px;object-fit:cover;border-radius:6px}

  /* filter gallery */
  .filters{display:flex;gap:8px;overflow:auto;padding:8px}
  .filter-card{width:88px;flex:0 0 88px;border-radius:8px;background:rgba(255,255,255,0.02);padding:6px;text-align:center;cursor:pointer}
  .filter-card canvas{width:100%;height:56px;border-radius:6px;display:block}

  /* properties drawer */
  .props{flex:0 0 220px;background:var(--card);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
  .props input, .props select, .props textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#fff}

  /* saved projects modal */
  .modal{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:linear-gradient(0deg,rgba(0,0,0,0.6),rgba(0,0,0,0.6));z-index:60}
  .modal .box{width:92%;max-width:720px;background:#071022;padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
  .saved-list{display:flex;flex-wrap:wrap;gap:8px}
  .saved-card{flex:0 0 160px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}

  /* responsive */
  @media (max-width:900px){
    .row{flex-direction:column}
    .left-panel{order:1;width:100%;flex:unset}
    .timeline-panel{order:3}
    .props{order:2;width:100%;flex:unset}
    #previewCanvas{aspect-ratio:16/9}
  }
</style>
</head>
<body>

<header>
  <div class="logo"><img src="scenecraft.png" alt="SceneCraft" onerror="this.style.display='none'"><div style="display:flex;flex-direction:column">
    <div class="title">SceneCraft</div>
    <div class="small" style="margin-top:2px">Powered by MaskNova</div>
  </div></div>

  <div style="margin-left:12px">
    <input id="projectName" placeholder="Untitled Project" style="background:transparent;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:10px;color:#fff">
  </div>

  <div class="top-actions">
    <button class="btn ghost" id="openSaves">📂 Saved Projects</button>
    <button class="btn" id="saveProj">Save Project</button>
    <button class="btn" id="exportBtn">Export</button>
  </div>
</header>

<div class="wrap">

  <div class="preview-card">
    <div id="previewCanvas" style="display:block"></div>
    <div class="preview-controls">
      <button class="btn ghost" id="playBtn">Play</button>
      <button class="btn ghost" id="pauseBtn">Pause</button>

      <div style="flex:1"></div>

      <label class="small">Playback</label>
      <select id="playbackRate" class="small">
        <option value="0.5">0.5x</option>
        <option value="1" selected>1x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
      </select>

      <label class="small" style="margin-left:8px">Aspect</label>
      <select id="aspect" class="small">
        <option value="16/9">16:9</option>
        <option value="9/16">9:16</option>
        <option value="1/1">1:1</option>
      </select>
    </div>
  </div>

  <div class="tools" id="toolMenu">
    <div class="tool" data-tool="filters">🎨 Filters</div>
    <div class="tool" data-tool="text">📝 Text</div>
    <div class="tool" data-tool="audio">🎵 Audio</div>
    <div class="tool" data-tool="crop">✂️ Crop</div>
    <div class="tool" data-tool="ai">🤖 AI Tools</div>
    <div class="tool" data-tool="transitions">🔀 Transitions</div>
  </div>

  <div class="row">
    <aside class="left-panel">
      <div style="margin-bottom:8px">
        <label class="small">Upload Images / Video</label>
        <input type="file" id="fileInput" accept="image/*,video/*" multiple>
      </div>
      <div style="margin-bottom:8px">
        <label class="small">Upload Audio</label>
        <input type="file" id="audioInput" accept="audio/*">
      </div>

      <div style="margin-top:8px">
        <div class="small" style="margin-bottom:6px">Media Library</div>
        <div class="media-list" id="mediaList"></div>
      </div>
    </aside>

    <section class="timeline-panel">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div class="small">Timeline</div>
        <div class="small">Drag to reorder • Tap to edit</div>
      </div>
      <div class="timeline-list" id="timelineList"></div>

      <div style="margin-top:12px">
        <div class="small" style="margin-bottom:6px">Filters Preview</div>
        <div class="filters" id="filters"></div>
      </div>
    </section>

    <aside class="props">
      <div class="small" style="margin-bottom:8px">Clip Properties</div>
      <div id="propsBox">
        <div class="small">Select a clip to edit its properties</div>
      </div>

      <hr style="opacity:0.06;margin:12px 0">

      <div class="small" style="margin-bottom:6px">Add Text Overlay</div>
      <input id="textContent" placeholder="Caption or title">
      <div style="display:flex;gap:6px;margin-top:8px">
        <button class="btn ghost" id="addTextBtn">Add Text</button>
        <button class="btn ghost" id="clearTextBtn">Clear Text</button>
      </div>

      <div style="height:10px"></div>
      <div class="small" style="margin-top:8px">Export Settings</div>
      <label class="small">Resolution</label>
      <select id="exportRes" class="small">
        <option value="640">640×360</option>
        <option value="960" selected>960×540</option>
        <option value="1280">1280×720</option>
      </select>
      <label class="small" style="margin-top:6px">FPS</label>
      <select id="exportFps" class="small">
        <option value="24">24</option>
        <option value="30" selected>30</option>
        <option value="60">60</option>
      </select>
    </aside>
  </div>
</div>

<!-- Saved projects modal -->
<div class="modal" id="savesModal">
  <div class="box">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <strong>Saved Projects</strong>
      <button class="btn ghost" id="closeSaves">Close</button>
    </div>
    <div style="margin-bottom:8px">
      <input id="newSaveName" placeholder="Name for save" style="width:100%;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:#fff">
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="btn" id="saveCurrentAs">Save Current</button>
        <button class="btn ghost" id="clearAllSaves">Clear All</button>
      </div>
    </div>
    <div class="small">Tap to load a project</div>
    <div style="height:8px"></div>
    <div class="saved-list" id="savedList"></div>
  </div>
</div>

<footer style="padding:12px;text-align:center;color:var(--muted);font-size:13px">SceneCraft — Powered by MaskNova</footer>

<script>
/* SceneCraft Editor - fully working core
   - mediaLibrary stores dataURLs (so project saves are self-contained)
   - timeline stores clips referencing mediaLibrary ids
   - filters: CSS-like canvas filters
   - save/load via localStorage
   - export via MediaRecorder (webm)
*/

// ------------ state ------------
let mediaLibrary = []; // {id, type, name, dataURL}
let timeline = [];     // {id, mediaId, type, duration, startTrim, filter}
let overlays = [];     // text overlays [{text,x,y,size,color,clipIndex}]
let selectedClip = -1;
let playing = false, stopRequested=false;

// DOM
const fileInput = document.getElementById('fileInput');
const audioInput = document.getElementById('audioInput');
const mediaList = document.getElementById('mediaList');
const timelineList = document.getElementById('timelineList');
const filtersDiv = document.getElementById('filters');
const propsBox = document.getElementById('propsBox');
const previewCanvas = document.getElementById('previewCanvas');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const playbackRate = document.getElementById('playbackRate');
const aspect = document.getElementById('aspect');
const projectNameInput = document.getElementById('projectName');

const modal = document.getElementById('savesModal');
const openSavesBtn = document.getElementById('openSaves');
const closeSavesBtn = document.getElementById('closeSaves');
const savedList = document.getElementById('savedList');
const newSaveName = document.getElementById('newSaveName');
const saveCurrentAs = document.getElementById('saveCurrentAs');
const clearAllSaves = document.getElementById('clearAllSaves');
const saveProjButton = document.getElementById('saveProj');
const exportBtn = document.getElementById('exportBtn');

const textContent = document.getElementById('textContent');
const addTextBtn = document.getElementById('addTextBtn');
const clearTextBtn = document.getElementById('clearTextBtn');

const previewCtx = (() => {
  // create offscreen canvas element for drawing (so we can capture it)
  const canvas = document.createElement('canvas');
  canvas.width = 960; canvas.height = 540;
  document.getElementById('previewCanvas').appendChild(canvas);
  return canvas.getContext('2d');
})();

// responsive preview sizing
function resizePreview(){
  const el = previewCanvas;
  const rect = el.getBoundingClientRect();
  previewCtx.canvas.width = Math.round(rect.width);
  // set height based on aspect selection
  const asp = aspect.value;
  let [wA,hA] = asp.split('/').map(Number);
  previewCtx.canvas.height = Math.round(rect.width * (hA / wA));
  el.style.height = previewCtx.canvas.height + 'px';
}
window.addEventListener('resize', resizePreview);
aspect.addEventListener('change', resizePreview);
setTimeout(resizePreview, 50);

// ------------ helpers ------------
const uid = (n=6)=>Math.random().toString(36).slice(2,2+n);

// read files as dataURL and add to library
async function readFilesAsDataURLs(files){
  const out = [];
  for(const f of files){
    const dataURL = await new Promise((res,rej)=>{
      const r = new FileReader();
      r.onload = ()=>res(r.result);
      r.onerror = rej;
      r.readAsDataURL(f);
    });
    out.push({ id: uid(), type: f.type.startsWith('video/') ? 'video' : (f.type.startsWith('image/') ? 'image' : 'audio'), name: f.name, dataURL });
  }
  return out;
}

// add media to lib and UI
async function addMediaItems(items){
  for(const it of items){
    mediaLibrary.unshift(it);
    const el = document.createElement('div');
    el.className='media-item';
    const thumb = document.createElement('div'); thumb.style.width='56px';thumb.style.height='40px';thumb.style.flex='0 0 56px';
    if(it.type==='image'){
      const img = document.createElement('img'); img.src = it.dataURL; thumb.appendChild(img);
    } else if(it.type==='video'){
      const vid = document.createElement('video'); vid.src = it.dataURL; vid.muted=true; vid.playsInline=true; vid.style.width='56px';vid.style.height='40px';vid.style.objectFit='cover'; thumb.appendChild(vid);
    } else {
      const ico = document.createElement('div'); ico.textContent='🎵'; ico.style.fontSize='22px'; ico.style.display='flex'; ico.style.alignItems='center'; ico.style.justifyContent='center'; thumb.appendChild(ico);
    }
    el.appendChild(thumb);

    const info = document.createElement('div'); info.style.flex='1';
    info.innerHTML=`<div style="font-weight:700">${it.name}</div><small>${it.type}</small>`;
    el.appendChild(info);

    const actions = document.createElement('div');
    const addBtn = document.createElement('button'); addBtn.className='btn ghost'; addBtn.textContent='Add'; addBtn.onclick=()=>{ addToTimeline(it.id); };
    actions.appendChild(addBtn);
    el.appendChild(actions);

    mediaList.prepend(el);
  }
  renderTimeline();
  renderFilters(); // regenerate thumbnails
}

// handle upload inputs
fileInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files || []);
  const items = await readFilesAsDataURLs(files);
  await addMediaItems(items);
  fileInput.value='';
});
audioInput.addEventListener('change', async (e)=>{
  const files = Array.from(e.target.files || []);
  const items = await readFilesAsDataURLs(files);
  await addMediaItems(items);
  audioInput.value='';
});

// add to timeline
function addToTimeline(mediaId){
  const media = mediaLibrary.find(m=>m.id===mediaId);
  if(!media) return;
  let duration = 4;
  if(media.type==='video'){
    // approximate duration by creating video element and using metadata
    const v = document.createElement('video');
    v.src = media.dataURL;
    v.addEventListener('loadedmetadata', ()=> {
      const dur = Math.min( Math.max(1, Math.floor(v.duration)), 120 );
      pushClip(mediaId,0,dur,dur);
    });
    return;
  }
  pushClip(mediaId,0,duration,duration);
}
function pushClip(mediaId,startTrim=0,duration=4){
  const media = mediaLibrary.find(m=>m.id===mediaId);
  const clip = { id: uid(), mediaId, type: media.type, startTrim, duration, filter:'none' };
  timeline.push(clip);
  renderTimeline();
}

// render timeline
function renderTimeline(){
  timelineList.innerHTML='';
  timeline.forEach((clip,i)=>{
    const media = mediaLibrary.find(m=>m.id===clip.mediaId);
    const card = document.createElement('div'); card.className='clip';
    card.onclick=()=> { selectedClip = i; showProps(); };
    const thumb = document.createElement('div');
    if(media.type==='image'){ thumb.innerHTML = `<img src="${media.dataURL}">`; }
    else if(media.type==='video'){ thumb.innerHTML = `<video src="${media.dataURL}" muted style="width:100%;height:72px;object-fit:cover"></video>`; }
    else { thumb.textContent='Audio'; }
    const tit = document.createElement('div'); tit.style.marginTop='6px'; tit.innerHTML = `<strong style="font-size:13px">${media.name}</strong><div class="small">${clip.type} • ${clip.duration}s</div>`;
    const actions = document.createElement('div'); actions.style.display='flex';actions.style.gap='6px';actions.style.marginTop='6px';
    const del = document.createElement('button'); del.className='btn ghost'; del.textContent='Delete'; del.onclick=(e)=>{ e.stopPropagation(); timeline.splice(i,1); renderTimeline(); propsBox.innerHTML='<div class="small">Select a clip to edit its properties</div>'; };
    const up = document.createElement('button'); up.className='btn ghost'; up.textContent='↑'; up.onclick=(e)=>{ e.stopPropagation(); if(i>0) moveClip(i,i-1); };
    const down = document.createElement('button'); down.className='btn ghost'; down.textContent='↓'; down.onclick=(e)=>{ e.stopPropagation(); if(i<timeline.length-1) moveClip(i,i+1); };
    actions.appendChild(up); actions.appendChild(down); actions.appendChild(del);
    card.appendChild(thumb); card.appendChild(tit); card.appendChild(actions);
    timelineList.appendChild(card);
  });
}

// move clip
function moveClip(from,to){
  const [it] = timeline.splice(from,1);
  timeline.splice(to,0,it);
  renderTimeline();
}

// show properties
function showProps(){
  propsBox.innerHTML='';
  if(selectedClip<0 || !timeline[selectedClip]){ propsBox.innerHTML='<div class="small">Select a clip to edit its properties</div>'; return; }
  const c = timeline[selectedClip];
  const m = mediaLibrary.find(x=>x.id===c.mediaId);
  const box = document.createElement('div');
  box.innerHTML = `<div style="font-weight:800">${m.name}</div><div class="small">${c.type}</div>`;
  box.style.marginBottom='8px';
  // trim duration
  const lbl1 = document.createElement('label'); lbl1.textContent='Duration (s)'; box.appendChild(lbl1);
  const dur = document.createElement('input'); dur.type='number'; dur.value=c.duration; dur.min=0.5; dur.onchange=()=>{ c.duration=Number(dur.value); renderTimeline(); };
  box.appendChild(dur);

  const lbl2 = document.createElement('label'); lbl2.textContent='Filter'; box.appendChild(lbl2);
  const sel = document.createElement('select');
  ['none','cinematic','bw','vintage','cyberpunk','neon','warm','cool'].forEach(s=>{ const o=document.createElement('option'); o.value=s; o.textContent=s; if(c.filter===s) o.selected=true; sel.appendChild(o); });
  sel.onchange=()=>{ c.filter = sel.value; };
  box.appendChild(sel);

  const playNow = document.createElement('button'); playNow.className='btn'; playNow.textContent='Play Clip'; playNow.style.marginTop='8px'; playNow.onclick=()=> playSingleClip(c);
  box.appendChild(playNow);

  propsBox.appendChild(box);
}

// filters gallery (predefined)
const FILTERS = [
  {id:'none',label:'None',fn: ctx=>ctx.filter='none'},
  {id:'cinematic',label:'Cinematic',fn: ctx=>ctx.filter='contrast(1.12) saturate(1.05)'},
  {id:'bw',label:'B&W',fn: ctx=>ctx.filter='grayscale(1)'},
  {id:'vintage',label:'Vintage',fn: ctx=>ctx.filter='sepia(0.4) saturate(0.9)'},
  {id:'cyberpunk',label:'Cyberpunk',fn: ctx=>ctx.filter='hue-rotate(200deg) saturate(1.5) contrast(1.1)'},
  {id:'neon',label:'Neon',fn: ctx=>ctx.filter='brightness(1.05) saturate(1.4)'},
  {id:'warm',label:'Warm',fn: ctx=>ctx.filter='sepia(0.15) saturate(1.1) contrast(1.02)'},
  {id:'cool',label:'Cool',fn: ctx=>ctx.filter='hue-rotate(190deg) saturate(0.95) contrast(1.02)'}
];

async function renderFilters(){
  filtersDiv.innerHTML='';
  for(const f of FILTERS){
    const card = document.createElement('div'); card.className='filter-card';
    const canvas = document.createElement('canvas'); canvas.width=160; canvas.height=90; card.appendChild(canvas);
    const lbl = document.createElement('div'); lbl.style.marginTop='6px'; lbl.style.fontSize='12px'; lbl.textContent=f.label; card.appendChild(lbl);

    // draw thumbnail: take first image/video from mediaLibrary or blank
    const ctx = canvas.getContext('2d');
    ctx.fillStyle='#111'; ctx.fillRect(0,0,canvas.width,canvas.height);
    const src = mediaLibrary.length ? mediaLibrary[0] : null;
    if(src){
      if(src.type==='image'){
        const img = new Image(); img.src = src.dataURL;
        await img.decode().catch(()=>{});
        ctx.save(); f.fn(ctx); ctx.drawImage(img,0,0,canvas.width,canvas.height); ctx.restore();
      } else if(src.type==='video'){
        const v = document.createElement('video'); v.src = src.dataURL; v.muted=true; v.playsInline=true;
        await new Promise(r=> v.addEventListener('loadeddata', r));
        try{ ctx.save(); f.fn(ctx); ctx.drawImage(v,0,0,canvas.width,canvas.height); ctx.restore(); } catch(e){}
      } else {
        // audio: show waveform-ish
        ctx.fillStyle='#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle='#4dd0e1'; for(let x=0;x<canvas.width;x+=6) ctx.fillRect(x, canvas.height/2 - (Math.random()*30), 4, Math.random()*60);
      }
    } else {
      ctx.fillStyle='#202020'; ctx.fillRect(8,8,canvas.width-16,canvas.height-16);
    }

    card.onclick = ()=> { applyGlobalFilter(f.id); };
    filtersDiv.appendChild(card);
  }
}

// apply global filter to preview draw
let globalFilter = 'none';
function applyGlobalFilter(filterId){ globalFilter = filterId; }

// overlays (text)
addTextBtn.addEventListener('click', ()=>{
  const txt = textContent.value.trim();
  if(!txt) return alert('Add text to insert');
  overlays.push({ id: uid(), text: txt, x: 0.5, y: 0.85, size: 28, color:'#ffffff' });
  textContent.value='';
});

// clear overlays
clearTextBtn.addEventListener('click', ()=>{ overlays.length=0; });

// playback engine
let timelinePlaying = false;
async function playTimeline(){
  if(timeline.length===0) return alert('Timeline empty');
  timelinePlaying = true; stopRequested=false;
  for(let i=0;i<timeline.length;i++){
    if(stopRequested) break;
    const clip = timeline[i];
    await playClipLive(clip);
  }
  timelinePlaying=false;
}
function stopPlayback(){ stopRequested=true; }

playBtn.onclick = ()=> { if(!timelinePlaying) playTimeline(); else alert('Already playing'); };
pauseBtn.onclick = ()=> stopPlayback();
pauseBtn.onclick = ()=> stopPlayback();

function playSingleClip(clip){
  (async ()=>{ await playClipLive(clip); })();
}

// draw helpers
function drawFrameImage(img, filterId){
  const ctx = previewCtx;
  const w = ctx.canvas.width; const h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  // apply filter
  const f = FILTERS.find(x=>x.id===filterId);
  ctx.save();
  if(f) f.fn(ctx);
  // cover
  const arSource = img.width / img.height;
  const arCanvas = w / h;
  let drawW = w, drawH = h, dx=0, dy=0;
  if(arSource > arCanvas){
    drawH = h; drawW = arSource * drawH; dx = -(drawW - w)/2;
  } else {
    drawW = w; drawH = drawW / arSource; dy = -(drawH - h)/2;
  }
  try{ ctx.drawImage(img, dx, dy, drawW, drawH); } catch(e){}
  ctx.restore();

  // draw text overlays
  for(const ov of overlays){
    ctx.font = `${ov.size}px sans-serif`;
    ctx.fillStyle = ov.color;
    ctx.textAlign = 'center';
    ctx.fillText(ov.text, w * ov.x, h * ov.y);
  }
}

// play clip live to preview (images/videos)
function playClipLive(clip){
  return new Promise(async (resolve)=>{
    const media = mediaLibrary.find(m=>m.id===clip.mediaId);
    if(!media){ resolve(); return; }
    const ctx = previewCtx;
    const w = ctx.canvas.width, h = ctx.canvas.height;
    const filterToUse = clip.filter || globalFilter;

    if(clip.type === 'image'){
      const img = new Image(); img.src = media.dataURL;
      await img.decode().catch(()=>{});
      const dur = Math.max(0.5, clip.duration || 4) / Number(playbackRate.value);
      const fps = 30;
      const frames = Math.max(1, Math.floor(dur * fps));
      for(let f=0; f<frames; f++){
        if(stopRequested) break;
        drawFrameImage(img, filterToUse);
        await new Promise(r=> setTimeout(r, 1000/fps));
      }
      resolve();
    } else if(clip.type === 'video'){
      const v = document.createElement('video');
      v.src = media.dataURL;
      v.muted = true; v.playsInline = true; v.crossOrigin='anonymous';
      v.currentTime = clip.startTrim || 0;
      const desiredDur = Math.min(clip.duration || 10, 300);
      v.playbackRate = Number(playbackRate.value);
      try{ await v.play(); } catch(e){ /* autoplay blocked */ }
      const endTime = (clip.startTrim || 0) + desiredDur;
      function step(){
        if(stopRequested || v.ended || v.currentTime >= endTime){
          try{ v.pause(); }catch(e){}
          resolve();
          return;
        }
        drawVideoFrame(v, filterToUse);
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    } else {
      // audio-only placeholder
      const dur = clip.duration || 4;
      const start = performance.now();
      while(performance.now() - start < dur*1000){
        if(stopRequested) break;
        await new Promise(r=>setTimeout(r,200));
      }
      resolve();
    }
  });
}

function drawVideoFrame(v, filterId){
  const ctx = previewCtx; const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  const f = FILTERS.find(x=>x.id===filterId);
  ctx.save(); if(f) f.fn(ctx);
  try{ ctx.drawImage(v, 0, 0, w, h); } catch(e){}
  ctx.restore();
  for(const ov of overlays){
    ctx.font = `${ov.size}px sans-serif`;
    ctx.fillStyle = ov.color;
    ctx.textAlign = 'center';
    ctx.fillText(ov.text, w * ov.x, h * ov.y);
  }
}

// EXPORT (record canvas)
exportBtn.onclick = async ()=>{
  if(timeline.length===0) return alert('Add clips first');
  // set export canvas size
  const exportWidth = Number(document.getElementById('exportRes').value);
  const aspectRatio = previewCtx.canvas.height / previewCtx.canvas.width;
  const exportHeight = Math.round(exportWidth * aspectRatio);
  // copy current preview canvas to new export canvas for correct size
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = exportWidth; exportCanvas.height = exportHeight;
  const exportCtx = exportCanvas.getContext('2d');
  // replace preview drawing functions to draw into export canvas temporarily
  const originalCanvas = previewCtx.canvas;
  const originalCtx = previewCtx;
  // create a wrapper draw function to draw frames into export canvas
  async function playForExport(){
    // for each clip, draw frames into exportCtx
    for(const clip of timeline){
      const media = mediaLibrary.find(m=>m.id===clip.mediaId);
      if(!media) continue;
      if(clip.type==='image'){
        const img = new Image(); img.src = media.dataURL; await img.decode().catch(()=>{});
        const dur = Math.max(0.5, clip.duration || 4);
        const fps = Number(document.getElementById('exportFps').value);
        const totalFrames = Math.max(1, Math.floor(dur * fps));
        for(let f=0; f<totalFrames; f++){
          // draw with filter
          exportCtx.clearRect(0,0,exportWidth,exportHeight);
          const ff = FILTERS.find(x=>x.id===clip.filter||globalFilter);
          if(ff) ff.fn(exportCtx);
          // draw image cover
          const arSource = img.width / img.height;
          const arCanvas = exportWidth / exportHeight;
          let drawW = exportWidth, drawH = exportHeight, dx=0, dy=0;
          if(arSource > arCanvas){
            drawH = exportHeight; drawW = arSource * drawH; dx = -(drawW - exportWidth)/2;
          } else {
            drawW = exportWidth; drawH = drawW / arSource; dy = -(drawH - exportHeight)/2;
          }
          try{ exportCtx.drawImage(img, dx, dy, drawW, drawH); } catch(e){}
          // draw overlays
          for(const ov of overlays){
            exportCtx.font = `${Math.round(ov.size * (exportWidth/previewCtx.canvas.width))}px sans-serif`;
            exportCtx.fillStyle = ov.color;
            exportCtx.textAlign = 'center';
            exportCtx.fillText(ov.text, exportWidth * ov.x, exportHeight * ov.y);
          }
          // yield frame to MediaRecorder by drawing to a visible canvas via captureStream?
          await new Promise(r=> setTimeout(r, 1000/fps));
        }
      } else if(clip.type==='video'){
        // draw video frames playing into export canvas
        const v = document.createElement('video');
        v.src = media.dataURL; v.muted=true; v.crossOrigin='anonymous';
        await new Promise(r=> v.addEventListener('loadeddata', r));
        const fps = Number(document.getElementById('exportFps').value);
        const dur = Math.min(clip.duration || (v.duration||4), v.duration||4);
        v.currentTime = clip.startTrim || 0;
        v.playbackRate = 1;
        try{ await v.play(); }catch(e){}
        const endTime = v.currentTime + dur;
        await new Promise(resolve=>{
          function tick(){
            if(v.ended || v.currentTime >= endTime){ v.pause(); resolve(); return; }
            exportCtx.clearRect(0,0,exportWidth,exportHeight);
            const ff = FILTERS.find(x=>x.id===clip.filter||globalFilter);
            if(ff) ff.fn(exportCtx);
            try{ exportCtx.drawImage(v, 0, 0, exportWidth, exportHeight); } catch(e){}
            for(const ov of overlays){
              exportCtx.font = `${Math.round(ov.size * (exportWidth/previewCtx.canvas.width))}px sans-serif`;
              exportCtx.fillStyle = ov.color;
              exportCtx.textAlign = 'center';
              exportCtx.fillText(ov.text, exportWidth * ov.x, exportHeight * ov.y);
            }
            // Using setTimeout synced to fps to avoid lock
            setTimeout(()=>requestAnimationFrame(tick), 1000/fps);
          }
          tick();
        });
      }
    }
  }

  // We'll record the previewCtx.canvas scaled to export size using captureStream
  const stream = previewCtx.canvas.captureStream(Number(document.getElementById('exportFps').value || 30));
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
  const chunks = [];
  recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };
  recorder.onstop = ()=> {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `${(projectNameInput.value||'scenecraft_project').replace(/\s+/g,'_')}.webm`; a.click();
  };

  // Start recording then play timeline into preview (the preview canvas is being recorded)
  recorder.start();
  stopRequested=false;
  await playTimeline(); // will draw onto previewCtx.canvas which is being recorded
  recorder.stop();
  alert('Export done — check your downloads. For higher-quality MP4 conversion, use server-side rendering.');
};

// Save/load projects using localStorage
const STORAGE_KEY = 'scenecraft_projects_v1';
function getSavedProjects(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); }catch(e){ return []; } }
function saveProjectToStorage(name){
  const data = {
    name: name || (projectNameInput.value || 'Untitled'),
    created: Date.now(),
    mediaLibrary,
    timeline,
    overlays,
    projectName: projectNameInput.value || 'Untitled'
  };
  const s = getSavedProjects();
  s.unshift(data);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  loadSavedList();
  alert('Project saved locally');
}
function loadSavedList(){
  const arr = getSavedProjects();
  savedList.innerHTML='';
  arr.forEach((p, idx)=>{
    const card = document.createElement('div'); card.className='saved-card';
    card.innerHTML = `<div style="font-weight:800">${p.name}</div><div class="small">${new Date(p.created).toLocaleString()}</div>`;
    const btnRow = document.createElement('div'); btnRow.style.display='flex';btnRow.style.gap='6px';btnRow.style.marginTop='8px';
    const loadBtn = document.createElement('button'); loadBtn.className='btn'; loadBtn.textContent='Load'; loadBtn.onclick=()=>{ if(confirm('Load this project? Unsaved changes will be lost.')) loadProjectAtIndex(idx); };
    const delBtn = document.createElement('button'); delBtn.className='btn ghost'; delBtn.textContent='Delete'; delBtn.onclick=()=>{ if(confirm('Delete this saved project?')){ deleteSavedAtIndex(idx); } };
    btnRow.appendChild(loadBtn); btnRow.appendChild(delBtn);
    card.appendChild(btnRow);
    savedList.appendChild(card);
  });
}
function loadProjectAtIndex(i){
  const s = getSavedProjects();
  const p = s[i];
  if(!p) return alert('Saved project not found');
  // replace current state
  mediaLibrary = p.mediaLibrary || [];
  timeline = p.timeline || [];
  overlays = p.overlays || [];
  projectNameInput.value = p.projectName || p.name;
  // rebuild UI
  mediaList.innerHTML=''; timelineList.innerHTML=''; propsBox.innerHTML='';
  addMediaItems(mediaLibrary.slice().reverse()); // addMediaItems expects array; we reverse for UI order
  // but above addMediaItems pushes onto mediaLibrary again => to avoid duplication, render directly:
  mediaList.innerHTML=''; for(const it of mediaLibrary){ // direct UI
    const el = document.createElement('div'); el.className='media-item';
    const thumb = document.createElement('div'); thumb.style.width='56px';thumb.style.height='40px';thumb.style.flex='0 0 56px';
    if(it.type==='image'){ const img=document.createElement('img'); img.src=it.dataURL; thumb.appendChild(img); }
    else if(it.type==='video'){ const v=document.createElement('video'); v.src=it.dataURL; v.muted=true; v.playsInline=true; v.style.width='56px';v.style.height='40px';v.style.objectFit='cover'; thumb.appendChild(v); }
    else{ const ico=document.createElement('div'); ico.textContent='🎵'; ico.style.fontSize='22px'; ico.style.display='flex'; ico.style.alignItems='center'; ico.style.justifyContent='center'; thumb.appendChild(ico); }
    el.appendChild(thumb);
    const info=document.createElement('div'); info.style.flex='1'; info.innerHTML=`<div style="font-weight:700">${it.name}</div><small>${it.type}</small>`;
    el.appendChild(info);
    const actions=document.createElement('div'); const addBtn=document.createElement('button'); addBtn.className='btn ghost'; addBtn.textContent='Add'; addBtn.onclick=()=>{ addToTimeline(it.id); };
    actions.appendChild(addBtn); el.appendChild(actions);
    mediaList.appendChild(el);
  }
  renderTimeline();
  renderFilters();
  modal.style.display='none';
}
function deleteSavedAtIndex(i){
  const s = getSavedProjects();
  s.splice(i,1);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  loadSavedList();
}

// UI hook ups for saves
openSavesBtn.onclick = ()=>{ loadSavedList(); modal.style.display='flex'; };
closeSavesBtn.onclick = ()=>{ modal.style.display='none'; };
saveCurrentAs.onclick = ()=>{ if(!newSaveName.value.trim()) return alert('Enter name'); saveProjectToStorage(newSaveName.value.trim()); newSaveName.value=''; };
clearAllSaves.onclick = ()=>{ if(confirm('Delete all saved projects?')){ localStorage.removeItem(STORAGE_KEY); loadSavedList(); alert('Cleared'); } };
saveProjButton.onclick = ()=>{ saveProjectToStorage(projectNameInput.value || ('Project ' + new Date().toLocaleString())); };

// initial render
renderFilters();
loadSavedList();
renderTimeline();
resizePreview();
</script>
</body>
</html>
